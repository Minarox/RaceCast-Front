<script>
    import { RemoteParticipant, RemoteTrackPublication, Room, RoomEvent, Track } from "livekit-client"
    import { Event, State, type Metadata, defaultMetadata, dispatchEvent } from "@types"
    import { actions } from "astro:actions"

    let nbViewers: number = 0
    let cameras: RemoteTrackPublication[] = []
    let microphones: RemoteTrackPublication[] = []
    let localStatus: State = State.DISCONNECTED
    let remoteStatus: State = State.DISCONNECTED
    let metadata: Metadata = defaultMetadata
    let room: Room | undefined = undefined

    document.addEventListener(Event.RESEND, (event: any): void => {
        switch (event.detail) {
            case Event.VIEWERS:
                dispatchEvent(Event.VIEWERS, nbViewers)
                break

            case Event.CAMERAS:
                dispatchEvent(Event.CAMERAS, cameras)
                break

            case Event.MICROPHONES:
                dispatchEvent(Event.MICROPHONES, microphones)
                break

            case Event.LOCAL_STATUS:
                dispatchEvent(Event.LOCAL_STATUS, localStatus)
                break

            case Event.REMOTE_STATUS:
                dispatchEvent(Event.REMOTE_STATUS, remoteStatus)
                break

            case Event.METADATA:
                dispatchEvent(Event.METADATA, metadata)
                break

            default:
                throw new Error(`Unknown event: ${event.detail}`)
        }
    })

    document.addEventListener(Event.CONNECT, () => {
        if (localStatus === State.DISCONNECTED) {
            setTimeout(() => connect())
        }
    })

    function getEmitterTracks(participant: RemoteParticipant): void {
        const tracks = Array.from(participant.trackPublications.values())

        let videoTracks = tracks.filter((track: RemoteTrackPublication) => track.kind === Track.Kind.Video)
        cameras = videoTracks.sort((a: any, b: any) => a?.trackInfo?.name.localeCompare(b?.trackInfo?.name))
        dispatchEvent(Event.CAMERAS, cameras)

        let audioTracks = tracks.filter((track: RemoteTrackPublication) => track.kind === Track.Kind.Audio)
        microphones = audioTracks.sort((a: any, b: any) => a?.trackInfo?.name.localeCompare(b?.trackInfo?.name))
        dispatchEvent(Event.MICROPHONES, microphones)
    }

    async function connect(): Promise<void> {
        const livekit = await actions.getLiveKitToken.orThrow()

        room = new Room({
            reconnectPolicy: {
                nextRetryDelayInMs: () => {
                    return 1000
                }
            }
        })

        room.prepareConnection(`wss://${livekit.domain}`, livekit.token)

        room
            .on(RoomEvent.ConnectionStateChanged, (state: string): void => {
                localStatus = state as State
                dispatchEvent(Event.LOCAL_STATUS, localStatus)

                if (localStatus === State.DISCONNECTED) {
                    room = undefined
                    nbViewers = 0
                    cameras = []
                    microphones = []
                    dispatchEvent(Event.VIEWERS, nbViewers)
                    dispatchEvent(Event.CAMERAS, cameras)
                    dispatchEvent(Event.MICROPHONES, microphones)
                    setTimeout(() => connect())
                }
            })
            .on(RoomEvent.RoomMetadataChanged, (data: string): void => {
                metadata = data ? JSON.parse(data) : defaultMetadata
                dispatchEvent(Event.METADATA, metadata)
            })
            .on(RoomEvent.ParticipantConnected, (participant): void => {
                if (participant.identity === livekit.publisherIdentity) {
                    getEmitterTracks(participant)
                    remoteStatus = State.CONNECTED
                    dispatchEvent(Event.REMOTE_STATUS, remoteStatus)
                } else {
                    nbViewers++
                    dispatchEvent(Event.VIEWERS, nbViewers)
                }
            })
            .on(RoomEvent.ParticipantDisconnected, (participant): void => {
                if (participant.identity === livekit.publisherIdentity) {
                    remoteStatus = State.DISCONNECTED
                    dispatchEvent(Event.REMOTE_STATUS, remoteStatus)
                } else {
                    nbViewers--
                    dispatchEvent(Event.VIEWERS, nbViewers)
                }
            })
            .on(RoomEvent.TrackPublished, (_, participant): void => {
                // if (participant.identity === livekit.publisherIdentity) {
                    getEmitterTracks(participant)
                // }
            })
            .on(RoomEvent.TrackUnpublished, (_, participant): void => {
                // if (participant.identity === livekit.publisherIdentity) {
                    getEmitterTracks(participant)
                // }
            })
            .on(RoomEvent.AudioPlaybackStatusChanged, (state: boolean): void => {
                if (!state) {
                    dispatchEvent(Event.NEED_USER_INTERACTION)
                }
            })

        await room.connect(`wss://${livekit.domain}`, livekit.token)
        metadata = room?.metadata ? JSON.parse(room.metadata) : defaultMetadata
        dispatchEvent(Event.METADATA, metadata)

        const emitter: RemoteParticipant | undefined = room.remoteParticipants.get(livekit.publisherIdentity)
        remoteStatus = emitter ? State.CONNECTED : State.DISCONNECTED
        dispatchEvent(Event.REMOTE_STATUS, remoteStatus)

        nbViewers = Array.from(room.remoteParticipants.keys()).length + 1 // +1 for the local participant
        if (emitter) {
            getEmitterTracks(emitter)
            nbViewers--
        } else {
            cameras = []
            microphones = []
            dispatchEvent(Event.CAMERAS, cameras)
            dispatchEvent(Event.MICROPHONES, microphones)
        }
        dispatchEvent(Event.VIEWERS, nbViewers)
    }
</script>
